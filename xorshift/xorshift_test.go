package prng

import (
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"testing"
	"time"
)

const (
	results = "results"

	fileHeader = `TESTING     : %#v
GENERATED BY: %+v < %#v
AT          : %s
`
)

var (
	u uint64

	shifts = map[string]XORShift{
		filepath.Join(results, "128plus_results.txt"):   new(Shift128Plus),
		filepath.Join(results, "1024start_results.txt"): new(Shift1024Star),
		filepath.Join(results, "4096star_results.txt"):  new(Shift4096Star),
		filepath.Join(results, "116plus_results.txt"):   new(Shift116Plus),
		filepath.Join(results, "64star_results.txt"):    new(Shift64Star),
	}
)

func init() {
	for k, _ := range shifts {
		shifts[k].Seed()
	}
	checkDir()
}

func checkDir() {
	if _, err := os.Stat("results"); err != nil {
		if !os.IsNotExist(err) {
			panic(err)
		}

		if err = os.Mkdir("results", 0755); err != nil {
			panic(err)
		}
	}
}

func BenchmarkShift(b *testing.B) {
	b.ResetTimer()

	for key, _ := range shifts {

		r := shifts[key]

		var x uint64
		for i := 0; i < b.N; i++ {
			x = r.Next()
		}
		u = x

	}
}

func TestShifts(t *testing.T) {
	cmd := exec.Command("dieharder", "-a", "-f", "-")

	for key, _ := range shifts {

		r := shifts[key]

		stdin, err := cmd.StdinPipe()
		if err != nil {
			t.Error(err)
		}

		file, err := os.Create(key)
		if err != nil {
			t.Error(err)
		}
		defer file.Close()

		cmd.Stdout = io.MultiWriter(os.Stdout, file)
		file.WriteString(fmt.Sprintf(fileHeader, r, cmd.Args, r, time.Now().Format(time.RFC1123)))

		cmd.Start()

		ch := make(chan struct{})
		var stop struct{}
		go func() {
			for {
				select {
				case <-ch:
					close(ch)
					return
				default:
					io.WriteString(stdin, fmt.Sprintf("%d\n", r.Next()))
				}
			}
		}()

		if err := cmd.Wait(); err != nil {
			t.Errorf("Received error: %v. Do you have dieharder installed?", err)
		}

		ch <- stop
		stdin.Close()
	}
}
